正则表达式
动机：
１．计算机处理文本已经成为计算机主要工作内容
２．根据文本的内容进行固定的筛选匹配是文本处理中常用的工作之一
３．为了快速方便的解决上诉问题，正则表达式应用而生，并且主键发展为
一个单独的技术，可以被众多编程语言使用

定义：及高级的文本模式匹配，提供了搜索和替代等功能，本质是由一些字符和
　　　　特殊符号组成的字符串，这个字符串描述这些字符和字符的某种重复方式，
　　　　按照这种方式，可以匹配一个相似特征规则的字符集和，
目标：
１．理解什么是正则表达式及正则表达式用途
２．能够掌握正则表达式规则和用法
３．能够使用python re模块进行基于正则表达式的文本操作

特点和用途
１．使用编程进行文本的检索和修改
２．正则表达式支持语言众多，方便使用
３．正则表达式可以匹配一系列字符串而不是某一个，匹配更多样化
４．在mongo中可以存储正则表达式，也可以使用正则表达式做查找操作
５．大量使用在爬虫中用来处理html文本匹配
django    tornado 

正则表达式规则和用法：
import re
re.findall('regex','string')
功能：在string字符串中，匹配regex正则表达式能够匹配的项，
放到一个列表中返回
元字符的使用

普通字符串
元字符：abc
匹配规则：匹配字符串的值

使用　　或　　进行多个匹配
元字符：re1 ｜ re2
匹配规则：既能匹配正则表达式re1所表达式内容，也能匹配re2所表达式内容

* 点好　　　'.'
元字符：.
匹配规则：匹配任意一个字符
匹配示例：
re.findall('.c','abcdf')　　　＝＝》['bc']

匹配开头子串
元字符：　　^
匹配规则：匹配一个字符串的开头位置
匹配示例：　^from 匹配以from开头的字符串
re.findall('^from','from china from i') #['from']

元字符：$
匹配规则：当一个字符串以什么结尾时使用$标记
re.findall('py$','from chinapy from i.py')
  
元字符：* 
匹配规则：匹配前面出现的字符0次或多次
re.findall('..*','abababbbb from i.py')　＃['ab', 'ab', 'abbbb']

元字符：+
匹配规则：匹配前面出现的字符1次或多次
re.findall('ab+','aebababbbb from i.py')

元字符：　?
匹配规则：匹配前面出现的字符或正则表达式0次或1次
re.findall('ab?','aeabeabb')

元字符：　{N}
匹配规则：匹配前面的出现的字符或re指定次数
re.findall('v{3}d{3}','aeabeabbvvvddd')
＃['vvvddd']

元字符：　{M,N}
匹配规则：匹配前面的出现的字符或re指定次数M到N次

字符集合匹配
１．元字符：[abcd]
匹配规则：匹配中括号任意一个字符
re.findall('[ab][cd]','aeabeabbdvvvddd')  #['bd']

元字符：[0-9] [a-zA-Z0-9] [3-8]
匹配规则：匹配中括号中任意一个区间内的字符

字符集合不匹配
元字符：[^...]  ...表示上面两项中任意内容
匹配规则：匹配任意非中括号中的字符集
匹配示例：re.findall('[^a-z]','aedab1j2^vvd')　＃['1', '2', '^']

匹配（非）数字字符
元字符：　　\d   \D　　　　　　
匹配规则：\d匹配任意一个数字字符    #[0-9]
　　　　　　　　\D匹配任意一个非数字字符  #[^0-9]

匹配（非）字母字符
元字符：　　\w   \W
匹配规则：\w匹配任意一个字母或数字字符  #[a-zA-Z0-9]
　　　　　　　　\W匹配任意一个非字母或数字字符 #[^a-zA-Z0-9]  

匹配（非）空字符
元字符：\s  空格　\n \0 \t \r \S
匹配规格：\s  匹配任意一个空字符
　　　　　　　　\S  匹配任意一个非空字符

匹配字符串开头和结尾
元字符　　\A(^)   \Z($)
匹配规则：\A  匹配字符串的开头位置
　　　　　　　　\Z  匹配字符串结尾位置
re.findall('\Aabc\Z','abcabc')　　　＃[]

匹配（非）单词边界
元字符：　\b   \B
匹配规则　　\B将非字母的部分不认为是单词部分
　　　　　　　　\b将连续字母的部分认为是一个单词
re.findall(r'\bis\b','This is a %test%')　　＃['is']

总结
匹配单个字符：　. [] \d \D \w \W \s \S
匹配重复次数：　* + ? {}
匹配开头结尾：　^ $ \A \Z \b \B
其他：　　　　　　　｜　[^]

raw子串和转义
r"hello world"   raw 子串
raw子串特点：　　　　不进行转义解析
'hello \n world'   \n表示换行
r'hello \n world'   \n表示两个字符

什么时候加r
转义raw字符串是为了防止python对字符串的转义解析，
所以在正则表达式本身有'\'的时候最好加上r
当匹配正则表达式内的特殊字符的时候，正则表达式本身也需要进行转义，
如要匹配字符串的* 则正则表达式应为　'\*'

贪婪和非贪婪
贪婪模式：不做处理的情况下，正则表达式默认是贪婪模式，在使用
* + ? {} 时候尽可能多的进行匹配
非贪婪模式：　贪婪模式 加 ?
即　*?   +?   ??   {m,m}?

１．正则表达式可以分组，分组的标志即括号（），每个括号都是正则表达式
的一个子组，而每个子组是整体正则表达式的一部分，同时也是一个小的
正则表达式
２．当有多个子组的时候，我们从外层分别叫第一子组，第二子组，当同一层次的
时候，从左向右分别计数
３．分组会改变* + ? {}  的重复行为，即把每个分组当做一个整体对待
　　进行相应的重复操作
４．
５．每个组都可以起名字，我们可以根据起的名字
re.findall(r'(?P<word>\b\w+\b)','hello world')
#['hello', 'world']

格式：(?P<word>hello)
给子组(hello)起一个名字，这个名字是'word'
子组通过名字进行调用(?P=word) 表示复制子组正则表达式内容
re.findall(r'(?P<word>\s+(?P=word))','hello world')
[('hello hello','hello')]

1.匹配长度8-10位的密码，必须字母开头，数字字母下划线组成
^[a-zA-Z][_a-zA-Z0-9]{7,9}$
2.匹配简单的身份证
\d{17}(\d|x )


说明：
１．以下七个函数是正则表达式匹配的常用函数
２．这七个函数既可以使用re直接调用，也可以使用re.compile()生成的
正则表达式对象来调用，其功能完全相同
３．使用re模块直接调用的时候，这些函数第一参数需要传入正则表达式
，而使用compile是对象调用的时候，因为已经确定了正则表达式，所以不需要再传入

eg:
re.findall(r'\w+','hello word')
obj=re.compile(r'\w+')
obj.findall('hello word')

findall:获取字符串中所有能被正则表达式匹配的子串，以列表返回，如果加子组
则返回每个子组中的内容
finditer:同findall　只返回是一个迭代器，每次迭代取得的是一个match对象
split: 将一个字符串，按照正则表达式的匹配内容进行分割，得到分割后的列表
sub(restring,repl,string,max=0)
    将正则表达式匹配的string字符串的内容替换为repl
    max如果不写则表示全部替换，如果赋值则表示最多替换为max处
    s1=re.sub(r'[A-Z]','***','Hello Word Love China',3)
subn　　同sub只不过多返回一个替代个数
match: 匹配正则表达式对应的内容，但是只能匹配一项
注意：match匹配的内容要求必须在正则表达式的起始位置，否则匹配不到
　　　　match匹配到对应的内容返回match object 否则返回None
search:同match,search所匹配内容不要求位置，这和match函数不同
作用：通用match object的属性和函数可以获取更加详细的匹配信息