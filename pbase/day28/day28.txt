
阻塞：指调用某个方法时，当前的执行流程会被挂起，只有当这个函数
　　　　返回结果时才会被继续执行
非阻塞：当调用某个方法时，没有被立即挂起，
同步：执行指令是一步步，有序的
异步：执行流程可能被打断，有很大的不确定性

得到id
import os
os.getpid()

关于多进程的创建方式：
１．os.fork():
fork　的主进程不会等子进程（造成了孤儿进程），主进程和子进程都要干活
２．Process()
主进程等待子进程，主进程和子进程都要干活
３．pool()
一般而言主进程要等子进程，主进程不要干活，而去调配子进程们干活

线程Thread:
进程（Process)与线程（Thread)
进程：程序加载运行一次抽象，进程是操作系统分配资源的单位
线程：是操作系统执行流程的分配单位，是分配时间片的单位
一个进程之中至少有一个线程

from threading import Thread　　

threading.Thread:
  Thread(target=None,args=None)
  start（）　　开启执行流程就绪状态
  run()
  join()   等待线程执行完毕；
  close()
  is_alive() 看线程是否还在工作
  name　　　　　　　线程的名字
  ident　　　　　　线程的id
  daemon     是否守护线程

什么是死锁？
多个执行流程，多个资源，并且执行流程需要获取这多个资源的 情况下，
有可能会出现某些执行流程各获取一部分资源，从而导致多个执行流程进入假死
的等待状态，著名的哲学家进餐问题就是一个典型的死锁问题
解决方案：
　１．避免互斥问题，使用信号量　缺点：和资源特性有关
　２．请求与保持条件，当一个线程因为请求资源而阻塞时放手
　　例如：Queue get(block=True,timeout=None)
 3.保证资源获取的有序性

 python 中线程的问题
     GIL(Global Interperter Lock)全局解释锁，
     多线程在真正运行时仍然是一种单线程


总结：
什么时候用多进程？什么时候用多线程？
１．计算密集型的场景用多进程
ideone_j8bR2b.py
2.I/O密集型的场景用多线程
下载文件，网络爬虫，数据库操作
注：轻量级的协程也适合I/O

使用进程池用到要用队列通信时，
使用multiprocessing.Manager().Queue()
不要用multiprocessing

作业：
１．实现面向对象线程版本的定时器
２．双进程跑满双核CUP，并且截图
３．大作业：把一个文件夹下面至少１０００个文件拷贝到另一个文件夹下面
，使用多进程（进程池，多线程，线程池）
怎么证明你拷贝的文件没有问题，
什么是哈希(Hash)？　
给一段信息做指纹：指纹是唯一的，没有碰撞

