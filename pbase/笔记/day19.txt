2017年１２月２８日　　星期四　　第１９天

运算符重载　operator overload
作用：
让自定义的对象（实例）像内建对象一样进行运算符操作
说明：
运算符重载方法的参数已经有固定的含义，不建议改变原意义
　
算术运算符：
加法＋　　＝＝> __add__(self,other)方法
减法－　　＝＝> __sub__(self,other)方法
乘法*　　＝＝> __mul__(self,other)方法
除法/　　＝＝> __truediv__(self,other)方法
地板除//　　＝＝> __floordiv__(self,other)方法
取模（取余）　　＝＝> __mod__(self,other)方法
幂**　　＝＝> __pow__(self,other)方法

反向运算符的重载：
__radd__(self,lhs)  加法　　lhs/self
__rsub__(self,lhs)  减法　　lhs/self
__rmul__(self,lhs)  乘法　　lhs/self
__rtruediv__(self,lhs)  除法　　lhs/self
__rfloordiv__(self,lhs)  地板除　　lhs/self
__rmod__(self,lhs)  取余　　lhs/self
__rpow__(self,lhs)  幂　　lhs/self

rhs   right hand side

复合赋值运算符重载
__iadd__(self,other)    加法 self+=other
__isub__(self,other)    减法 self-=other
__imul__(self,other)    乘法 self*=other
__itruediv__(self,other)    除法 self/=other
__ifloordiv__(self,other)    地板法 self//=other
__imod__(self,other)    求余 self%=other
__ipow__(self,other)    幂法 self**=other

一元运算符的重载：
__neg__  负号 -
__pos__   正号  +
__invert__ 取反 ~

语法：
def __xxx__(self):
   ...

比较运算符：
__lt__   <
__le__   <=
__gt__   >
__ge__   >=
__eq__   ==
__ne__   !=
注：比较运算符通常返回布尔值True 或False

位运算符：
__and__    &
__or__    |
__xor__  ^
__lshift__  <<
__rshift__  >>
__invert__  ~
反向位运算
__rand__
__ror__
__rxor__
__rlshift__  <<
__rrshift__  >>

交集　&       __and__(self,rhs)
并集 |       __or__(self,rhs)
补集 -       __sub__(self,rhs)
对称补集 ^    __xor__(self,rhs)
==/!= 等     __ne__(self,rhs)

练习：
实现有序集合类orderset(),能实现两个集合的

s1=OrderSet([1,2,3,4])
s2=OrderSet([3,4,5])
print(s1&s2)   #OrderSet([3,4])

if OrderSet([1,2,3])!=OrderSet([1,2,3,4])
    print('不相等')
if 2 in s1:
    print('2在s1中')

in  /not in
格式：
def __contains__(self,e:'元素')：
　　　...
索引和切片运算符的重载
重载方法：
__getitem__(self,i):   用于索引切片取值
__setitem__(self,i,v)　　用于索引切片赋值
__delitem__(self,i)　　用del语句删除索引或切片操作
作用：
让自定义类型的对象支持索引和切片操作


切片运算符的重载：
类　slice
数据：：
slice.start  切片的起始索引
slice.stop　　　终止索引
slice.step　　　步长

迭代器（高级篇）
迭代器是可以通过next()函数取值的对象，就是迭代器
迭代器协议：
迭代器协议是指对象能够使用next函数 获取下一项数据，在没有下
一项数据时，触发一个StopInteration 异常来终止迭代的约定
迭代器协议的实现方法：
__next__(self)方法来实现迭代器协议

什么是可迭代对象：
指能用iter(obj)函数返回迭代器的对象（实例）
iter(obj)对应的方法是__iter__(self),来返回迭代器对象

异常（高级篇）
with 语句
语法：
with 表达式１[as 变量１]，表达式２[as 变量２]，...
　　　　语句块
作用：
使用于对资源进行访问的场合，确保使用过程中不管是否发生异常，
都会执行必要有“清理”操作，并释放资源
例如：文件的使用后自动关闭，线程中锁的自动获取和释放等
说明：
１．先执行　表达式　用　as子句中的变量绑定生成的对象
　　然后执行with语句内部的部分
２．with语句同try-finally类似，他不会改变异常的状态

环境管理器：
类内有__enter__和__exit__方法的类被称为环境管理器
能够用with语句进行管理的对象必须是环境管理器
__enter__将在进入with语句时被调用并返回由as变量绑定的对象
__exit__将在离开with语句时被调用，且可以用参数来判断离开with
语句

练习：
1.写一个类Myprimes,实现迭代器协议，让类能生成从b开始到e结束的
全部素数
class Myprimes:
    def __init__(self,b,e):
        ..
    def __iter__(self):
      ..
    def __next__(self):
l=[x for x in Myprimes(10,20)]
print(l)  #[11,13,17,19]
2.写一个列表类Mylist实现存储整数的列表，类的定义如下：
class Mylist:
    def __init__(self,it=None):
        self.data=[...]
让此类的对象能返回迭代器进行访问
让此类的对象能用len(x)函数求取长度
思考：
如何此类对象用sum()函数求和　
