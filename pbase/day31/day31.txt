io并发服务器

io input output
sys.stdin  sys.stdout
我们把内存中数据的交换操作都可以称为io操作，例如，文件的读写，网络信息的传入传出

io操作和cpu计算不同，因为需要数据的交换所以速度较慢
所有对于一个程序来说如何更好的解决io传输速率的问题往往决定程序执行效率

具有大量io操作的程序称之为io密集型程序
具有较多c pu运算操作的程序称之计算机密集型程序

io分类
阻塞io　　非阻塞io　　io多路复用（事件驱动io，异步io）
阻塞io：默认io既阻塞的，阻塞IO在一定条件下会结束阻塞
条件阻塞：因为不满足某种条件，使进程处于等待状态。当等待条件被触发时，
　　　既结束阻塞状态，比如：accept,recv
传输阻塞：数据在交换的过程中需要通过内核进行读写，这个读写的过程需要一定的事件，这个时间
　　　也是处于阻塞的状态
解决方案：
　　　将阻塞条件设置为非阻塞，不在等待条件达到

针对传输阻塞：
　　　在内核处理IO操作的时间里，应用层程序不在等待，而是继续执行自己
　　　的任务，等到内核处理IO结束会告知应用层程序，此时在进行应用层IO处理，多路复用　
非阻塞IO 
    非阻塞IO在遇到原本的阻塞时，不再阻塞，但是如果想处理相应的事件就必须不断
    轮回，需要消耗一定的计算机资源

sockfd.setblocking(False) 设置sockfd套接字为非阻塞套接字（默认为True阻塞)

IO多路复用
win--->select
linux/unix-->select poll epoll 
1.同时监测多个IO事件
２．当检测的IO事件被触发则返回处理相应的事件
３。当监测的IO事件没有准备好时，可以选择等待，
４．IO多路复用在内核中实际是一种轮询，需要消耗资源，相对阻塞等待效率高，
　　　　但不是真的异步

import select
select.select(rlist,wlist,elist,[timeout])
功能：设置要监听的IO事件
参数:
rlist:列表　　　将想要处理的IO放在列表中，当列表中有IO事件就绪
　　　　　　　　　　　　就会告知应用层
wlist:列表　　我们下一步想要操作的文件描述符放到这个列表中则下次返回时就
　　　　　　　　　　　会返回给应用层
elist:列表　　将我们可能要进行异常处理的IO事件放在这个列表中，当其中的IO
　　　　　　　　　　　事件发生异常时，就会返回给应用层处理
[timeouot]:超时时间，如果不写select为一直阻塞，如果设置了时间，则
　　　　　　　　　　　select在阻塞了n秒后结束等待
返回值：　在rlist  wlist elist 三个列表中至少一个列表有一个IO事件需要
　　　　　　　　应用层处理时返回
rs:是一个列表对应rlist列表中如果有IO准备就绪则放到rs中
ws:是一个列表对应rlist列表中如果有IO准备就绪则放到ws中
es:是一个列表对应rlist列表中如果有IO准备就绪则放到es中

poll 实现多路复用

POLLIN POLLOUT POLLERR POLLUP 　　POLLPRI 　　　POLLVAL
rlist  wlist   elist   断开连接　　　紧急处理　　　无效数据

s.fileno() 函数返回系统对应的数字

epoll 效率比poll和select高

协程：
    又称微线程，本质是单线程，创建协程资源消耗少
    可用于高并发的IO处理，无需上写文切换的开销
    无需资源争夺，保证对数据的原子操作

    缺点：
    无法利用多核资源，一旦阻塞会阻塞整个程序的运行

底层实现使用yield关键字，通过yield可以模拟协程的过程常见模块

greenlet
sudo pip3 install greenlet  安装模块

gevent
sudo pip3 install gevent  安装模块

作业：
１类似ＱＱ群聊，在聊天室中允许多个用户加入聊天室
２．加入一个简单的用户注册（不需要数据库，临时存储即可）
３.客户端发送消息时，其他客户端可以收到，但是本人收不到，收到的
消息是　　name say message
4.如果有用户进入聊天室或退出聊天室，其他客户端收到通知
　　name login
  name logout
5.支持管理员喊话，server发送消息