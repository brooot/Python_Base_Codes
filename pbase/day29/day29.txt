吕泽　lvze@tedu.cn
ip地址：
windows
win+r
输入　cmd
ipconfig

liunx
在shell命令输入ifconfig

osi模型（面试常用）
是网络传输的一个标准化模型，是计算机网络体系结构发展的产物
七层模型
应用层　　提供osi的用户服务，例如处理程序，文件传输协议和数据管理

表示层　　完成数据的转换和文本压缩加密

会话层　　提供进程间的连接建立，选择使用什么样的传输层协议

传输层　　建立网络连接，提供适合的传输服务，提供透明的传输服务
　　　　　　　提供端到端的流量控制

网络层　　控制分组传送　路由器选择　网络互连

链路层　　提供链路的交换，具体的数据发送功能

物理层　　物理硬件，提供具体的传输条件和传输接口规定

实际应用

网络四层模型：　是基于osi七层模型世界情况的整合
应用层　　应用层，表示层，会话层
传输层　　传输层
网络层　　网络层
物理链路层　　链路层，物理层

协议：网络协议，是通信双方必须共同遵循的一个约定，如怎么
连接，怎么进行识别

tcp协议：传输控制协议　传输层
udp协议：用户数据报协议　传输层
ip协议：　网络协议　　　　　　网络层
http协议：超文本协议　　　　应用层
import socket
In [2]: socket.gethostname()
Out[2]: 'tedu'
In [3]: socket.gethostbyname('localhost')
Out[3]: '127.0.0.1'

IPV4
192.168.    1.  235　　　　每段0~255
网段号　　　　  网关　　主机号 
127.0.0.1   本机回环ip　　做本机的网络实验上使用IP  
IP地址转换成二进制字节串
socket.inet_pton(socket.AF_INET,'192.168.1.2')

反向转换
socket.inet_ntop(socket.AF_INET,'192.168.1.2')

端口号：为了区分一台主机收到的数据包转交给哪个进程处理

本质是一个整数0-65535
1-1023  由众所周知的系统程序占用
1024-10000很多安装程序会使用
10000以上　我们自己写程序最好用１００００以上

查看某个程序的端口
socket.getservbyname('http')

dns(域名解析器)
字码掩码：配合IP使用，过滤当前网段
字节序
主机字节序有两种：
大端序　　高字节存在低地址位
小端序　　低序字节存在低地址位
将１６位网络字节序转化为本地
socket.ntohs(8)
将１６位本地字节序转化为网络字节序
socket.htons(1024)  #4
将３２位网络字节序转化为本地
socket.htonl(1024) #262144
将32位本地字节序转化为网络字节序
socket.ntohl(262144) #
bcd-lsp

套接字socket
网络间通信的手法，是一个io接口规范，在linux下socket 本身是一种
文件类型，叫做套接字文件，类似open产生的文件描述符

套接字分类：
流式套接字（SOCK_STREAM)
　　　提供了面向连接的传输服务，在传输使用TCP协议通信
数据报套接字（SOCK_DGRAM)
　　　提供了面向无连接的传输服务，在传输使用UDP协议通信
原始套接字（SOCK_RAM)
  针对底层协议编程的，如IP,ICMP，的直接访问,主要用作交换机等偏网络设备的编程

面向连接：可靠的传输服务，需要先建立网络之间的连接关系（三次握手）
　　　数据无差错，无重复，无失序
面向无连接：数据发送前不需要确认连接，数据传输不可靠，有可能产生丢失，重复或者失序

TCP网络通信
适用情况：对传输质量要求较高，数据传输量需要较大，需要可靠性支持
建立连接的过程（三次握手）
断开连接的过程（四次挥手）

服务器端：
1.创建套接字（流式套接字）

#from socket import * 
import socket
socket.socket(sock_family＝AF_INET,socket_type=SOCK_STREAM,protoco1=0)
参数：sock_family:AF_INET AF_UNIX  地址族类型
　　　　　socket_type:SOCK_STREAM(流式套接字)
　　　　　　　　　　　　　　　　　SOCK_DGRAM(数据包套接字)
     protoco1:一般使用默认值
返回值：返回创建的套接字
2.绑定服务器IP和PORT端口号
    sockfd.bind(ADDR)
３．将套接字设置为监听套接字，并且创建监听队列大小
　　　　socket.listen(５)
4.阻塞等待接听客户端连接请求
　　　　socket.accept()
5.接收发送消息
connfd.send()
connfd.recv()

6.关闭套接字
connfd.close()
sockfd.close()

客户端
１．创建socket套接字
２．发起连接请求
sockfd.connect(ADDR)
３．接收发送请求
sockfd.send()
data = sockfd.recv()
４．关闭套接字
sockfd.close()

粘包：指发送方发送若干数据包的时候，因为是数据流的方式导致
    数据连接在一起，从缓冲区接收后一数据紧挨着一数据
    如果是大文件分组发送时我们不需要处理，但是如果是若干相干
    文件进行分别发送那么就需要处理粘包问题
处理方法：
１格式化数据　　将数据格式化加以规定，可以规定字节数或规定以什么结尾
２．发送长度
３．每次放松后有个短暂的延迟，不适合大数据多次发送

作业：
写一个简单文件服务器
server
client
