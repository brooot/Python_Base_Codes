进程的创建流程
１、用户空间通过运行程序或者调用接口发起创建进程
２、操作系统功能接受用户请求，开始创建进程
３、操作系统功能分配计算机资源，确定进程状态，开辟进程空间等工作
４、操作系统将创建好的进程提供给应用程序使用


cpu时间片
如果一个进程占有计算机核心，我们称为该进程占有计算机cpu时间片。

* 多个任务之间是争夺cpu的关系
* 谁占有cpu最终由操作系统决定


PCB(进程控制块)
在内存中开辟的一块空间，用来记录进程的信息

* PCB是操作系统功能查找识别进程的标志

查看进程信息的命令 ： ps - aux

PID(process ID): 进程ID，由操作系统功能自动分配，是个正整数

父子进程：在系统中除了初始化进程，每个进程都有父进程，可能有0个或者多个子进程。由此形成父子进程关系。


查看进程树： pstree
查看父进程PID ：ps -ajx

查看进程优先级：top
    动态查看系统中的进程信息，用 < > 翻页
    取值范围  -20 到 19 ,  -20 级别最高


使用指定的优先级运行程序
    nice ： 指定运行的优先级

    e.g.  nice -9 ./while.py  以优先级9运行
          nice --9 ./while.py 以优先级-9运行（通常需要root权限）

进程特征

1、进程间互不影响，独立运行
2、进程是操作系统资源分配的最小单位
3、每个进程空间独立，各自占有一定的虚拟内存




多进程编程

import os

pid = os.fork()
功能： 创建新的进程
参数： 无
返回值：  失败：返回一个负数
        成功： 1、在原有的进程中返回新的进程的PID
              2、在新的进程中返回0

进程相关函数

获取进程PID
os.getpid()

获取父进程PID
os.getppid()


进程退出

os._exit(status)
功能： 进程退出
参数： 进程的退出状态

sys.exit([status])
功能： 进程退出
参数： 数字表示退出状态，不写默认为0
      字符串，表示退出时打印的内容

* sys.exit 可以通过捕获 SystemExit异常防止退出


孤儿进程：父进程先于子进程退出，此时子进程就称为孤儿进程

* 孤儿进程会被操作系统指定的进程收养，系统系统进程就成为孤儿进程的新的父进程


僵尸进程：子进程先于父进程退出，但是父进程没有处理子进程的退出状态，此时父进程就会成为僵尸进程

* 僵尸进程会存留少量PCB信息在内存中，大量的僵尸进程会消耗系统资源，应当避免僵尸进程的产生


如何避免僵尸进程产生
    * 处理子进程退出状态
        pid, status = os.wait()
        功能： 在父进程中阻塞等待处理子进程退出
        返回值： pid    退出的子进程的PID号
                status  获取子进程的退出状态
        pid, status = os.w
        waitpid(pid, option)
        功能： 在父进程中阻塞等待处理子进程退出
        参数： pid -1  表示等待任意子进程退出
                   >0 表示等待对应PID号的子进程退出
             option  0      表示阻塞等待
                    os.WNOHANG 表示非阻塞
        返回值： pid    退出的子进程的PID号
                status  获取子进程的退出状态
    * 让父进程先退出
        1、父进程创建子进程等待子进程退出
        2、父进程创建二级子进程后立即退出
        3、二级子进程称为孤儿，和原来的父进程各自执行事件



Multiprocessing 模块创建进程

	1、需要将要执行的事情封装成函数
	2、使用multiprocessing模块中的Process类创建进程对象
	3、通过对象属性设置和Process的初始胡函数对进程进行设置，绑定要执行的函数
	4、启动进程，会自动执行进程绑定的函数
	5、完成进程的回收

	process()
	功能： 创建进程对象
	参数： name   进程名称 Process-1
	      target 绑定函数
	      args   元组   给target函数按照位置传参
	      kwargs 字典  给target函数按照键值对传参

	p.start()
	功能： 启动进程
	*  target 函数会自动执行，此时进程真正被创建


	p.join([timeout])
	功能： 阻塞等待回收子进程
	参数： 超时时间

	*   使用multiprocessing创建子进程，同样子进程复制父进程的全部代码段，
	  父子进程各自执行互不影响，父子进程有各自的运行空间

	*   如果不使用join回收子进程则子进程退出后会成为僵尸进程

	*   使用multiprocessing创建子进程往往父进程只是用来创建进程、回收进程


	Process进程对象属性

	p.start()
	p.join()

	p.is_alive()  判断进程生命周期状态，处于生命周期得到True ，否则返回False

	p.name 进程名称  默认为Process-1

	p.pid  进程的pid

	p.daemon
	默认状态False  主进程退出不会影响子进程执行
	如果设置为True  则子进程会随着主进程的结束而结束

	* 要在 start 前设置

	* 一般不和join一起使用 

	注意：p.daemon 并非守护进程

	********************************************
	注意：
	1、如果子进程从父进程拷贝对象，且对象和网络或者文件相关联，那么父子进程会使用同一套对象属性，相互有一定的关联性
	2、如果在子进程中单独创建对象，则和父进程完全没有关联





多进程

	优点：  可以使用计算机多核，进行任务的并发执行，提高执行效率
	       空间独立，数据安全
	       运行不受其他进程影响，创建方便

	缺点：  进程的创建和删除消耗的系统资源较多


	进程池技术
	产生原因： 如果有大量任务需要多进程完成，则可能需要频繁的创建删除进程，给计算机带来较多的资源消耗

	原理： 创建适当的进程放入进程池，用来处理待处理事件，处理完毕后进程不销毁，仍然在进程池中等待处理其他事件。进程的复用降低了资源的消耗。


	使用方法：
	1、创建进程池，在池内放入适当的进程
	2、将事件加入到进程池等待队列
	3、不断取进程执行事件，知道所有事件执行完毕
	4、关闭进程池，回收进程


from multiprocessing import Pool

Pool(processes)
功能：创建进程池对象
参数：表示进程池中有多少进程

pool.apply_async(func, args, kwds)
功能：将事件放入进程池队列，等待执行
参数：func事件函数
      args以元组形式给func传参
      kwds以字典形式给func传参
返回值：  返回一个代表进程池事件的对象，若记为r，则通过r.get()函数可以得到事件函数的返回值


pool.apply(func, args, kwds)
功能：将事件放入进程池队列
参数：func事件函数
      args以元组形式给func传参
      kwds以字典形式给func传参
返回值：无


pool.close()
功能：关闭进程池，不能再往进程池中添加事件

pool.join()
功能：回收进程池（阻塞函数）

pool.map(func, iter)
功能： 将要做的事件放入进程池
参数： func  要执行的函数
       iter  迭代对象
返回值： 返回事件函数的返回值列表


********************************************************

进程间通信 （IPC）

原因： 进程空间相对独立，资源无法相互获取，此时在不同进程间通信需要专门方法。

进程间通信方法： 管道  消息队列  共享内存  信号  信号量 套接字 





管道通信  Pipe

    通信原理： 在内存中开辟管道空间，生成管道操作对象，多个进程使用”同一个“管道对象进行操作即可实现通信

    multiprocessing ---> Pipe

    fd1, fd2 = Pipe(duplex = True)
    功能： 创建管道
    参数： 默认表示双向管道
          如果设置duplex为False，则为单向管道
    返回值： 表示管道的两端
            如果是双向管道 都可以读写
            如果是单项管道 则 fd1只读  fd2只写

    fd.recv()
    功能： 从管道读取信息
    返回值： 读取到的内容

    - 如果管道为空则阻塞

    fd.send(data)
    功能： 向管道写入内容
    参数： 要写入的内容

    - 可以发送python数据类型，不一定要是bytes格式







消息队列

    队列： 先进先出
    通信原理： 在内存中建立数据结构模型。多个进程都可以通过队列存入内容，取出内容的顺序和存入顺序保持一致

    创建队列

    q = Queue(maxsize = 0)

    功能： 创建消息队列
    参数： 表示最多存放多少消息。 默认表示根据内存分配存储
    返回值： 队列对象

    q.put(data,[block,timeout])

    功能： 向队列存储消息
    参数： data 要存的内容
    		block 默认队列满时会阻塞，设置为False 则非阻塞
    		timeout 超时时间

    data =  q.get([block, timeout])

    功能： 获取队列消息
    参数： block 默认队列空时会阻塞， 设置为False 则非阻塞
          timeout 超时时间
    返回值： 返回取出的内容

    q.full()  判断队列是否为满
    q.empty()  判断队列是否为空
    q.qsize()  判断队列中消息数量
    q.close()  关闭队列



共享内存

    通信原理： 在内存中开辟一块空间，对多个进程可见，进程可以写入输入，
    但是每次写入的内容会覆盖之前的内容

    obj = Value(ctype, obj)
    功能： 开辟共享内存空间
    参数： ctype  要存储的数据类型
           obj   共享内存的初始化数据
    返回： 共享内存对象

    obj.value 即为共享内存值，对其修改即修改共享内存


    *  ctype =enum('c','b','B','i','I','l','L','f','d')

    obj = Array(ctype, obj)
    功能： 开辟共享内存空间
    参数： ctype 要存储的数据格式
          obj  初始化存入的内容， 比如列表、字符串
                如果是整数则表示开辟空间的个数
    返回值： 返回共享内存对象

            * 可以通过遍历获取每个元素的值
            e.g.  [1,2,3]  --->  obj[1] == 2

            * 如果存入的是字符串
            obj.value  表示字符串的首地址



            管道              消息队列            共享内存

开辟方式     内存               内存                内存

读写方式     两端读写           先进先出          覆盖之前的内容    
            双向/单向

效率         一般               一般                较高

应用         多用于父子进程     广泛灵活        需要注意进行互斥操作




信号通信
    
    一个进程向另一个进程发送一个信号来传递某种讯息，接受者根据接受到的信号
    进行相应的行为

    kill -l         查看系统信号
    kill -sig  PID  向一个进程发送信号

    关于信号
    信号名称    信号含义    默认处理方法

    SIGHUP      连接断开
    SIGINT      ctrl+c
    SIGQUIT     ctrl+\
    SIGTSTP     ctrl+z
    SIGKILL     强制终止一个进程
    SIGSTOP     强制暂停一个进程
    SIGALARM    时钟信号
    SIGCHID     子进程状态改变时给父进程发出

    

    python 发出信号

        使用signal模块

        os.kill(pid, sig)
        功能： 发送信号
        参数： pid 目标进程
              sig 要发送的信号





        signal.alarm(sec)
            功能： 向自身发送时钟信号 -->  SIGALARM
            参数： sec  时钟时间

          * 进程中只能同时存在一个时钟，第二个会覆盖之前的。

            同步执行： 按照顺序逐句执行
            异步执行： 在执行过程中利用内核记录延迟发生或者准备处理的事件。这样不影响
                     应用层的持续执行。当事件发生时再由内核告知应用层处理

            * 信号是唯一的异步通信方法


        signal.pause()
        功能： 阻塞等待接收一个信号
        参数： 无


        signal.signal(signum, handler)
        功能： 处理信号
        参数： signum 要处理的信号
              handler 信号的处理方法：
                        SIG_DFL  表示使用默认的方法处理
                        SIG_IGN  表示忽略这个信号
                        func     传入一个函数，用该指定函数处理
                                def func(sig,frame)
                                     sig:   捕获到的信号
                                     frame： 信号结构对象

    
××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××

信号量（信号灯）

    原理： 给定一个数量，对多个进程可见，且多个进程都可以操作。
          进程通过对数量多少的判断执行各自的行为。

    multiprocessing -->  Semaphore()

    sem = Semaphore(num)
    功能： 创建信号量
    参数： 信号量初始值
    返回： 信号量对象


    sem.get_value()  获取信号量值

    sem.acquire()   将信号量减 1    当信号量为0 时会阻塞

    sem.release()   将信号量加 1


*****************************************************************


进程的同步与互斥


    临界资源： 多个进程或者线程都能够操作的共享资源
    
    临界区： 操作临界资源的代码段


    同步： 一种合作关系，为完成某个任务，多进程或者多线程之间形成一种协调，
    按照约定或条件执行操作临界资源。

        
    互斥： 互斥是一种制约关系，当一个进程或者线程使用临界资源时进行上锁处理，
    其他想使用该资源的进程会阻塞等待，知道解锁后才能使用。


    Event  事件

        multiprocessing --> Event

        创建事件对象
        e = Event()

        设置事件阻塞
        e.wait([timeout])

        事件设置(结束阻塞)
        e.set()

        清除设置  当事件被clear后  e.wait() 又会阻塞
        e.clear()

        事件状态判断
        e.is_set()  True 为 非阻塞   False 为 阻塞




    Lock 锁

        创建对象
        lock = Lock()

        方式1：
        lock.acquire()  上锁  如果已经是上锁状态调用此函数会阻塞

        lock.release()  解锁

        方式2：
        with lock:      进入with lock语句内自动上锁
            ....
            ....

                        退出with lock语句自动解锁


××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××


线程

线程也是一种多任务编程方法，可以利用计算机多核资源完成程序的并发执行。
线程又被称为轻量级的进程

线程特性
* 线程是计算机多核分配的最小单位
* 一个进程可以包含多个线程
* 公用一个进程空间
*


t = threading.Thread()

    功能： 创建线程对象
    参数： name   进程名称 Thread-1
          target 绑定函数
          args   元组   给target函数按照位置传参
          kwargs 字典  给target函数按照键值对传参

    t.start()
    功能： 启动线程
    *  target 函数会自动执行，此时线程真正被创建


    t.join([timeout])
    功能： 阻塞等待回收线程
    参数： 超时时间

    t.is_alive()





线程对象属性

t.name
t.setName()
t.getName()
threading.currentThread()

t.daemon 属性
默认情况主线程退出不会影响分支线程执行

设置方法：
t.daemon = True
t.setDaemon(True)

判断属性值
t.isDaemon()

* 要在start前设置，不会和join同用





创建自己的线程类
    见day6 中的 MyThread.py




线程通信
    
    通信方法： 多个线程共享进程的空间， 所以线程间通信使用全局变量完成。
    
    注意事项： 线程间使用全局变量往往要同步互斥机制
             保证通信安全

线程同步互斥方法

线程的Event
e = threading.Event()  创建事件对象
e.wait({timeout})  如果e为设置状态则不阻塞，否则阻塞
e.set()    将e变成设置状态
e.clear()  清除设置




线程锁Lock
lock = threading.Lock()  创建锁对象
lock.acquire()  上锁
lock.release()  解锁


*  也可以通过with上锁，上锁状态用acquire会阻塞


==================================================================

python线程的GIL问题  （全局解释器锁）

python -->  支持多线程 --> 同步互斥问题 --> 加锁 
-->  超级锁，给解释器加锁 --> 解释器同一时刻只能解释一个线程

后果： 一个解释器同一时刻只能解释执行一个线程，所以导致python线程效率低下。
    但是当遇到IO阻塞时线程会主动让出解释器，因此python线程更加适合高延迟的IO程序并发

解决方法：
* 尽量用进程完成并发
* 不使用c解释器  如c# java
* 尽量使用多种方案组合的方式进程并发操作，线程用作高延迟IO(如网络的收发)


===================================================================

进程he线程的区别与联系

    1 两者都是多任务编程方式，都能使用计算机的多核资源
    2 进程的创建删除消耗更多计算机资源
    3 进程空间独立，数据相互不干扰，有专门的IPC，线程使用全局变量进行通信
    4 一个进程可以创建多个线程分支，两者之间存在包含关系
    5 多个线程公用进程资源，在资源操作是往往需要同步互斥
    6 进程线程在系统中都有自己特有的属性，ID，代码段，栈区等资源


使用场景
    * 需要创建较多并发，同时任务关联性比较强时一般用多线程
    * 不同的任务模块可能更多使用进程
    * 使用进程线程需要考虑数据的处理复杂度，比如进程(线程)间通信是否方便，同步互斥是否过于复杂


要求：
1 进程线程的区别和联系
2 进程间通信方式都知道哪些，有什么特点
3 同步互斥的意义是什么，什么情况下用
4 给一个情形，分析下用进程还是线程，理由
5 一些常见概念挖掘： 僵尸进程， 进程状态，GIL




=================================================================
#在父进程中忽略子进程状态改变,子进程退出自动由操作系统处理
signal.signal(signal.SIGCHLD, signal.SIG_IGN)
****************************************************************

ftp文件服务器

项目功能
* 服务端和客户端,要求启动一个服务端,可以同时处理多个客户端请求
* 功能: 
    1.可以查看服务端文件库中所有的普通文件
    2.从客户端可以下载文件库的文件到本地
    3.可以将本地文件上传的服务端文件库
    4.退出

* 客户端使用print在终端打印简单的命令提示,通过命令提示发起请求

1.技术分析 (fork tcp 并发)
2.每个功能要单独封装,整体功能写在一个类中
3.如何搭建整体架构,完成网络通讯

功能分析
1.获取文件列表
    客户端:    
        * 发送请求
        * 得到回复判断能否获取列表
        *  接受文件名称列表打印
    服务器:
        * 接受请求
        * 判断请求列表
        * 判断能否满足请求,回复信息确认
        * 执行请求发送文件列表

cookie:
os.listdir(path)  查看目录下的文件
os.path.isfile()  判断是否为普通文件
os.path.isdir()   判断是否为目录


cookie

import traceback

traceback.print_exc()
功能: 更详细的打印异常信息

==================================================================

集成模块的使用
python2 SocketServer
python3 sockerServer

功能: 通过模块的不同类的组合完成多进程/多线程的 tcp/udp 的并发

==================================================================

HTTPServer  V2.0

==================================================================

协程基础

    定义: 纤程，微线程。本质是一个单线程程序，所以协程不能使用计算机多核资源。

    作用：　能够搞笑的完成并发任务，占用较少的资源。因此协程的并发量较高。

    原理：　通过记录应用层的上下文栈区，实现在运行中进行上下文跳转，达到可以
    选择性的运行想要运行的部分，以提高程序的运行效率。


    优点：　  
            消耗资源少
            无需切换开销
            无需同步互斥
            ＩＯ并发性好

    缺点：　　　
            无法利用计算机多核


yield --> 协程实现的基本关键字

greenlet
    greenlet.greenlet()  生成协程对象
    gr.switch()  选择要执行的协程事件

gevent
    1 将协程事件封装为函数
    2 生成协程对象
        gevent.spawn(func, argv)
        功能： 生成协程对象
        参数： func  协程函数
              argv  给协程函数传参(不定参)
        返回值： 返回协程对象

    3 回收协程
        gevent.joinall()
        功能： 回收协程
        参数： 列表 将要回收的协程放入列表

        gevent.sleep(n)
        功能： 设置协程阻塞，让协程跳转
        参数： n  阻塞时间
        

        from gevent import monkey
        monkey.patch_all()
        功能： 修改套接字的IO阻塞行为

        * 必须在socket模块导入之前使用，见day5/gevent_server.py