进程的创建流程
１、用户空间通过运行程序或者调用接口发起创建进程
２、操作系统功能接受用户请求，开始创建进程
３、操作系统功能分配计算机资源，确定进程状态，开辟进程空间等工作
４、操作系统将创建好的进程提供给应用程序使用


cpu时间片
如果一个进程占有计算机核心，我们称为该进程占有计算机cpu时间片。

* 多个任务之间是争夺cpu的关系
* 谁占有cpu最终由操作系统决定


PCB(进程控制块)
在内存中开辟的一块空间，用来记录进程的信息

* PCB是操作系统功能查找识别进程的标志

查看进程信息的命令 ： ps - aux

PID(process ID): 进程ID，由操作系统功能自动分配，是个正整数

父子进程：在系统中除了初始化进程，每个进程都有父进程，可能有0个或者多个子进程。由此形成父子进程关系。


查看进程树： pstree
查看父进程PID ：ps -ajx

查看进程优先级：top
    动态查看系统中的进程信息，用 < > 翻页
    取值范围  -20 到 19 ,  -20 级别最高


使用指定的优先级运行程序
    nice ： 指定运行的优先级

    e.g.  nice -9 ./while.py  以优先级9运行
          nice --9 ./while.py 以优先级-9运行（通常需要root权限）

进程特征

1、进程间互不影响，独立运行
2、进程是操作系统资源分配的最小单位
3、每个进程空间独立，各自占有一定的虚拟内存




多进程编程

import os

pid = os.fork()
功能： 创建新的进程
参数： 无
返回值：  失败：返回一个负数
        成功： 1、在原有的进程中返回新的进程的PID
              2、在新的进程中返回0

进程相关函数

获取进程PID
os.getpid()

获取父进程PID
os.getppid()


进程退出

os._exit(status)
功能： 进程退出
参数： 进程的退出状态

sys.exit([status])
功能： 进程退出
参数： 数字表示退出状态，不写默认为0
      字符串，表示退出时打印的内容

* sys.exit 可以通过捕获 SystemExit异常防止退出


孤儿进程：父进程先于子进程退出，此时子进程就称为孤儿进程

* 孤儿进程会被操作系统指定的进程收养，系统系统进程就成为孤儿进程的新的父进程


僵尸进程：子进程先于父进程退出，但是父进程没有处理子进程的退出状态，此时父进程就会成为僵尸进程

* 僵尸进程会存留少量PCB信息在内存中，大量的僵尸进程会消耗系统资源，应当避免僵尸进程的产生


如何避免僵尸进程产生
    * 处理子进程退出状态
        pid, status = os.wait()
        功能： 在父进程中阻塞等待处理子进程退出
        返回值： pid    退出的子进程的PID号
                status  获取子进程的退出状态
        pid, status = os.w
        waitpid(pid, option)
        功能： 在父进程中阻塞等待处理子进程退出
        参数： pid -1  表示等待任意子进程退出
                   >0 表示等待对应PID号的子进程退出
             option  0      表示阻塞等待
                    os.WNOHANG 表示非阻塞
        返回值： pid    退出的子进程的PID号
                status  获取子进程的退出状态
    * 让父进程先退出
        1、父进程创建子进程等待子进程退出
        2、父进程创建二级子进程后立即退出
        3、二级子进程称为孤儿，和原来的父进程各自执行事件



Multiprocessing 模块创建进程

	1、需要将要执行的事情封装成函数
	2、使用multiprocessing模块中的Process类创建进程对象
	3、通过对象属性设置和Process的初始胡函数对进程进行设置，绑定要执行的函数
	4、启动进程，会自动执行进程绑定的函数
	5、完成进程的回收

	process()
	功能： 创建进程对象
	参数： name   进程名称 Process-1
	      target 绑定函数
	      args   元组   给target函数按照位置传参
	      kwargs 字典  给target函数按照键值对传参

	p.start()
	功能： 启动进程
	*  target 函数会自动执行，此时进程真正被创建


	p.join([timeout])
	功能： 阻塞等待回收子进程
	参数： 超时时间

	*   使用multiprocessing创建子进程，同样子进程复制父进程的全部代码段，
	  父子进程各自执行互不影响，父子进程有各自的运行空间

	*   如果不使用join回收子进程则子进程退出后会成为僵尸进程

	*   使用multiprocessing创建子进程往往父进程只是用来创建进程、回收进程


	Process进程对象属性

	p.start()
	p.join()

	p.is_alive()  判断进程生命周期状态，处于生命周期得到True ，否则返回False

	p.name 进程名称  默认为Process-1

	p.pid  进程的pid

	p.daemon
	默认状态False  主进程退出不会影响子进程执行
	如果设置为True  则子进程会随着主进程的结束而结束

	* 要在 start 前设置

	* 一般不和join一起使用 

	注意：p.daemon 并非守护进程

	********************************************
	注意：
	1、如果子进程从父进程拷贝对象，且对象和网络或者文件相关联，那么父子进程会使用同一套对象属性，相互有一定的关联性
	2、如果在子进程中单独创建对象，则和父进程完全没有关联





多进程

	优点：  可以使用计算机多核，进行任务的并发执行，提高执行效率
	       空间独立，数据安全
	       运行不受其他进程影响，创建方便

	缺点：  进程的创建和删除消耗的系统资源较多


	进程池技术
	产生原因： 如果有大量任务需要多进程完成，则可能需要频繁的创建删除进程，给计算机带来较多的资源消耗

	原理： 创建适当的进程放入进程池，用来处理待处理事件，处理完毕后进程不销毁，仍然在进程池中等待处理其他事件。进程的复用降低了资源的消耗。


	使用方法：
	1、创建进程池，在池内放入适当的进程
	2、将事件加入到进程池等待队列
	3、不断取进程执行事件，知道所有事件执行完毕
	4、关闭进程池，回收进程


from multiprocessing import Pool

Pool(processes)
功能：创建进程池对象
参数：表示进程池中有多少进程

pool.apply_async(func, args, kwds)
功能：将事件放入进程池队列，等待执行
参数：func事件函数
      args以元组形式给func传参
      kwds以字典形式给func传参
返回值：  返回一个代表进程池事件的对象，若记为r，则通过r.get()函数可以得到事件函数的返回值


pool.apply(func, args, kwds)
功能：将事件放入进程池队列
参数：func事件函数
      args以元组形式给func传参
      kwds以字典形式给func传参
返回值：无


pool.close()
功能：关闭进程池，不能再往进程池中添加事件

pool.join()
功能：回收进程池（阻塞函数）

pool.map(func, iter)
功能： 将要做的事件放入进程池
参数： func  要执行的函数
       iter  迭代对象
返回值： 返回事件函数的返回值列表


********************************************************

进程间通信 （IPC）

原因： 进程空间相对独立，资源无法相互获取，此时在不同进程间通信需要专门方法。

进程间通信方法： 管道  消息队列  共享内存  信号  信号量 套接字 





管道通信  Pipe

    通信原理： 在内存中开辟管道空间，生成管道操作对象，多个进程使用”同一个“管道对象进行操作即可实现通信

    multiprocessing ---> Pipe

    fd1, fd2 = Pipe(duplex = True)
    功能： 创建管道
    参数： 默认表示双向管道
          如果设置duplex为False，则为单向管道
    返回值： 表示管道的两端
            如果是双向管道 都可以读写
            如果是单项管道 则 fd1只读  fd2只写

    fd.recv()
    功能： 从管道读取信息
    返回值： 读取到的内容

    - 如果管道为空则阻塞

    fd.send(data)
    功能： 向管道写入内容
    参数： 要写入的内容

    - 可以发送python数据类型，不一定要是bytes格式







消息队列

    队列： 先进先出
    通信原理： 在内存中建立数据结构模型。多个进程都可以通过队列存入内容，取出内容的顺序和存入顺序保持一致

    创建队列

    q = Queue(maxsize = 0)

    功能： 创建消息队列
    参数： 表示最多存放多少消息。 默认表示根据内存分配存储
    返回值： 队列对象

    q.put(data,[block,timeout])

    功能： 向队列存储消息
    参数： data 要存的内容
    		block 默认队列满时会阻塞，设置为False 则非阻塞
    		timeout 超时时间

    data =  q.get([block, timeout])

    功能： 获取队列消息
    参数： block 默认队列空时会阻塞， 设置为False 则非阻塞
          timeout 超时时间
    返回值： 返回取出的内容

    q.full()  判断队列是否为满
    q.empty()  判断队列是否为空
    q.qsize()  判断队列中消息数量
    q.close()  关闭队列



共享内存

    通信原理： 在内存中开辟一块空间，对多个进程可见，进程可以写入输入，
    但是每次写入的内容会覆盖之前的内容

    obj = Value(ctype, obj)
    功能： 开辟共享内存空间
    参数： ctype  要存储的数据类型
           obj   共享内存的初始化数据
    返回： 共享内存对象

    obj.value 即为共享内存值，对其修改即修改共享内存


    *  ctype =enum('c','b','B','i','I','l','L','f','d')

    obj = Array(ctype, obj)
    功能： 开辟共享内存空间
    参数： ctype 要存储的数据格式
          obj  初始化存入的内容， 比如列表、字符串
                如果是整数则表示开辟空间的个数
    返回值： 返回共享内存对象

            * 可以通过遍历获取每个元素的值
            e.g.  [1,2,3]  --->  obj[1] == 2

            * 如果存入的是字符串
            obj.value  表示字符串的首地址



            管道              消息队列            共享内存

开辟方式     内存               内存                内存

读写方式     两端读写           先进先出          覆盖之前的内容    
            双向/单向

效率         一般               一般                较高

应用         多用于父子进程     广泛灵活        需要注意进行互斥操作




信号通信
    
    一个进程向另一个进程发送一个信号来传递某种讯息，接受者根据接受到的信号
    进行相应的行为

    kill -l         查看系统信号
    kill -sig  PID  向一个进程发送信号

    关于信号
    信号名称    信号含义    默认处理方法

    SIGHUP      连接断开
    SIGINT      ctrl+c
    SIGQUIT     ctrl+\
    SIGTSTP     ctrl+z
    SIGKILL     强制终止一个进程
    SIGSTOP     强制暂停一个进程
    SIGALARM    时钟信号
    SIGCHID     子进程状态改变时给父进程发出

    

    python 发出信号

        使用signal模块

        os.kill(pid, sig)
        功能： 发送信号
        参数： pid 目标进程
              sig 要发送的信号

        signal.alarm(sec)
        功能： 向自身发送时钟信号--》 SIGALARM
        参数： sec 时钟信号